<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>linux/fs: page to read</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">linux/fs
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('The.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">page to read </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="block__dev_8c.html#ad0c0eff304f2620313af627b2b7fcfab">bdev_read_page()</a> - Start reading a page from a block device : The device to read the page from : The offset on the device to read the page to (need not be aligned)</p>
<p>On entry, the page should be locked. It will be unlocked when the page has been read. If the block driver implements rw_page synchronously, that will be true on exit from this function, but it need not be.</p>
<p>Errors returned by this function are usually "soft", eg out of memory, or queue full; callers should try a different route to read this page rather than propagate an error back up the stack.</p>
<p>Return: negative errno if an error occurs, 0 if submission was successful.</p>
<p><a class="el" href="block__dev_8c.html#a8887a99582cfce8a37c18da1ff964707">bdev_write_page()</a> - Start writing a page to a block device : The device to write the page to : The offset on the device to write the page to (need not be aligned)</p>
<p>: The writeback_control for the write</p>
<p>On entry, the page should be locked and not currently under writeback. On exit, if the write started successfully, the page will be unlocked and under writeback. If the write failed already (eg the driver failed to queue the page to the device), the page will still be locked. If the caller is a -&gt;writepage implementation, it will need to unlock the page.</p>
<p>Errors returned by this function are usually "soft", eg out of memory, or queue full; callers should try a different route to write this page rather than propagate an error back up the stack.</p>
<p>Return: negative errno if an error occurs, 0 if submission was successful.</p>
<p>fscypt_encrypt_page() - Encrypts a page : The inode for which the encryption should take place </p><pre class="fragment">        encryption.
</pre><p> : Length of data to encrypt in</p>
<p><a class="el" href="crypto_2crypto_8c.html#ae398edfad4b1ece50e7b77d02e440f36">fscrypt_decrypt_page()</a> - Decrypts a page in-place : The corresponding inode for the page to decrypt. </p><pre class="fragment">        it is a writeback page (FS_CFLG_OWN_PAGES unset).
</pre><p> : Number of bytes in</p>
<p>: The fsdata (unused)</p>
<p>fscache_mark_page_cached - Mark a page as being cached : The retrieval op pages are being marked for</p>
<p>Mark a netfs page as being cached. After this is called, the netfs must call fscache_uncache_page() to remove the mark.</p>
<p>gfs2_writepage_common - Common bits of writepage</p>
<p>: The writeback control</p>
<p>Returns: 1 if writepage is ok, otherwise an error code or zero if no error.</p>
<p>gfs2_writepage - Write page for writeback mappings</p>
<p>: The writeback control</p>
<p>__gfs2_jdata_writepage - The core of jdata writepage</p>
<p>: The writeback control</p>
<p>This is shared between writepage and writepages and implements the core of the writepage operation. If a transaction is required then PageChecked will have been set and the transaction will have already been started before this is called.</p>
<p>This is the core of gfs2's readpage. It's used by the internal file reading code as in that case we already hold the glock. Also it's called by <a class="el" href="gfs2_2aops_8c.html#a2f00acb4af9a8becfec21351ec1e8cd9">gfs2_readpage()</a> once the required lock has been granted.</p>
<p>This deals with the locking required. We have to unlock and relock the page in order to get the locking in the right order.</p>
<p>gfs2_stuffed_write_end - Write end for stuffed files : The inode : The buffer_head containing the on-disk inode : The file position : The length of the write : How much was actually copied by the VFS</p>
<p>This copies the data from the page into the inode block after the inode data structure itself.</p>
<p>Returns: errno</p>
<p>: The fsdata (unused in GFS2)</p>
<p>The main write_end function for GFS2. We have a separate one for stuffed files as they are slightly different, otherwise we just put our locking around the VFS provided functions.</p>
<p>Returns: errno</p>
<p>jdata_set_page_dirty - Page dirtying function</p>
<p>Returns: 1 if it dirtyed the page, or 0 otherwise</p>
<p>gfs2_unstuffer_page - unstuff a stuffed inode into a block cached by a page : the inode : the dinode buffer : the block number that was allocated</p>
<p>Returns: errno</p>
<p>gfs2_unstuff_dinode - Unstuff a dinode when the data has grown too big : The GFS2 inode to unstuff</p>
<p>This routine unstuffs a dinode and returns it to a "normal" state such that the height can be grown in the traditional way.</p>
<p>Returns: errno</p>
<p>gfs2_allocate_page_backing - Use bmap to allocate blocks</p>
<p>We try to allocate all the blocks required for the page in one go. This might fail for various reasons, so we keep trying until all the blocks to back this page are allocated. If some of the blocks are already allocated, thats ok too.</p>
<p>gfs2_log_write_page - write one block stored in a page, into the log : The superblock</p>
<p>This writes the first block-sized part of the page into the log. Note that the page must have been allocated from the gfs2_page_pool mempool and that after this has been called, ownership has been transferred and the page may be freed at any time. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
